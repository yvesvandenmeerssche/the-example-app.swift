"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var rich_text_types_1 = require("@contentful/rich-text-types");
var unified_1 = __importDefault(require("unified"));
var remark_parse_1 = __importDefault(require("remark-parse"));
var markdownNodeTypes = new Map([
    ['paragraph', 'paragraph'],
    ['heading', 'heading'],
    ['text', 'text'],
    ['emphasis', 'text'],
    ['strong', 'text'],
    ['delete', 'text'],
    ['inlineCode', 'text'],
    ['link', 'hyperlink'],
    ['thematicBreak', 'hr'],
    ['blockquote', 'quote'],
    ['list', 'list'],
    ['listItem', 'list-item'],
]);
var nodeTypeFor = function (node) {
    var nodeType = markdownNodeTypes.get(node.type);
    switch (nodeType) {
        case 'heading':
            return nodeType + "-" + node.depth;
        case 'list':
            return (node.ordered ? 'ordered' : 'unordered') + "-list";
        default:
            return nodeType;
    }
};
var markTypes = new Map([['emphasis', 'italic'], ['strong', 'bold'], ['inlineCode', 'code']]);
var markTypeFor = function (node) {
    return markTypes.get(node.type);
};
var dataFor = function (node) {
    return node.type === 'link' ? { uri: node.url } : {};
};
var isLink = function (node) {
    return node.type === 'link';
};
var nodeContainerTypes = new Map([
    ['delete', 'block'],
    ['heading-1', 'block'],
    ['heading-2', 'block'],
    ['heading-3', 'block'],
    ['heading-4', 'block'],
    ['heading-5', 'block'],
    ['heading-6', 'block'],
    ['listItem', 'block'],
    ['blockquote', 'block'],
    ['thematicBreak', 'block'],
    ['list', 'block'],
    ['paragraph', 'block'],
    ['link', 'inline'],
    ['text', 'text'],
    ['emphasis]', 'text'],
    ['strong]', 'text'],
    ['inlineCode]', 'text'],
]);
var isBlock = function (nodeType) {
    return nodeContainerTypes.get(nodeType) === 'block';
};
var isText = function (nodeType) {
    return nodeContainerTypes.get(nodeType) === 'text';
};
var markdwonNodeToRichTextNode = function (node, fallback) {
    var nodeType = nodeTypeFor(node);
    var nodeContent = markdownNodesToRichTextNodes(node.children, fallback);
    var nodeValue = node.value;
    var nodeData = {};
    if (isLink(node)) {
        nodeData = dataFor(node);
    }
    if (isBlock(nodeType)) {
        return {
            nodeType: nodeType,
            content: nodeContent,
            data: nodeData,
        };
    }
    else if (isText(nodeType)) {
        var marks = [];
        if (node.type !== 'text') {
            // TODO: this implementation needs to handle arbitrarily nested marks
            // for example: **_Hello_, world!**
            nodeValue = node.content ? node.content[0].value : node.value;
            marks.push({
                type: markTypeFor(node),
            });
        }
        return {
            nodeType: nodeType,
            value: nodeValue,
            marks: marks,
            data: {},
        };
    }
};
var markdownNodesToRichTextNodes = function (nodes, fallback) {
    if (!nodes) {
        return [];
    }
    var richNodes = nodes
        .map(function (node) {
        var richNode = markdwonNodeToRichTextNode(node, fallback);
        if (!richNode) {
            return fallback(node);
        }
        return richNode;
    })
        .filter(Boolean);
    return richNodes;
};
var treeToRichTextDocument = function (tree, fallback) {
    return {
        nodeType: rich_text_types_1.BLOCKS.DOCUMENT,
        data: {},
        content: markdownNodesToRichTextNodes(tree.children, fallback),
    };
};
function richTextFromMarkdown(md, fallback) {
    if (fallback === void 0) { fallback = function (n) { return null; }; }
    var processor = unified_1.default().use(remark_parse_1.default, { commonmark: true });
    var tree = processor.parse(md);
    return treeToRichTextDocument(tree, fallback);
}
exports.richTextFromMarkdown = richTextFromMarkdown;
//# sourceMappingURL=index.js.map