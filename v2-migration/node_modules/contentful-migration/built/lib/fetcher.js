"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const Bluebird = require("bluebird");
class Fetcher {
    constructor(makeRequest) {
        this.makeRequest = makeRequest;
    }
    async getEntriesInIntents(intentList) {
        const ids = _.uniq(intentList.getIntents()
            .filter((intent) => intent.isContentTransform() || intent.isEntryDerive())
            .map((intent) => intent.getContentTypeId()));
        if (ids.length === 0) {
            return [];
        }
        let entries = [];
        let skip = 0;
        while (true) {
            const response = await this.makeRequest({
                method: 'GET',
                url: `/entries?sys.contentType.sys.id[in]=${ids.join(',')}&skip=${skip}`
            });
            entries = entries.concat(response.items);
            skip += response.items.length;
            if (skip >= response.total) {
                break;
            }
        }
        return entries;
    }
    async getContentTypesInChunks(intentList) {
        // Excluding editor interface intents here since, API-wise, editor interfaces don't require
        // to know the full details about the associated content type.
        const ids = _.uniq(intentList.getIntents()
            .filter((intent) => (!intent.isEditorInterfaceUpdate() &&
            !intent.isEditorInterfaceCopy() &&
            !intent.isEditorInterfaceReset()))
            .reduce((ids, intent) => {
            const intentIds = intent.getRelatedContentTypeIds();
            return ids.concat(intentIds);
        }, []));
        if (ids.length === 0) {
            return [];
        }
        const response = await this.makeRequest({
            method: 'GET',
            url: `/content_types?sys.id[in]=${ids.join(',')}`
        });
        let contentTypes = response.items;
        return contentTypes;
    }
    async getEditorInterfacesInIntents(intentList) {
        const contentTypeIds = _.uniq(intentList.getIntents()
            .filter((intent) => intent.isFieldRename() || intent.isEditorInterfaceUpdate() || intent.isEditorInterfaceReset() || intent.isEditorInterfaceCopy())
            .reduce((ids, intent) => {
            const intentIds = intent.getRelatedContentTypeIds();
            return ids.concat(intentIds);
        }, []));
        let editorInterfaces = new Map();
        if (contentTypeIds.length === 0) {
            return editorInterfaces;
        }
        for (let id of contentTypeIds) {
            await this._fetchEditorInterface(id, editorInterfaces);
        }
        return editorInterfaces;
    }
    async getLocalesForSpace() {
        const response = await this.makeRequest({
            method: 'GET',
            url: `/locales`
        });
        let locales = response.items.map((i) => i.code);
        return locales;
    }
    async checkContentTypesForDeletedCts(intentList, contentTypes) {
        const deletedCtIds = new Set(intentList.getIntents()
            .filter((intent) => intent.isContentTypeDelete())
            .map((intent) => intent.getContentTypeId()));
        if (deletedCtIds.size === 0) {
            return contentTypes;
        }
        const self = this;
        return Bluebird.map(contentTypes, async function (ct) {
            if (deletedCtIds.has(ct.id)) {
                const response = await self.makeRequest({
                    method: 'GET',
                    url: `/entries?sys.contentType.sys.id=${ct.id}`
                });
                if (response.items.length > 0) {
                    ct.hasEntries = true;
                }
            }
            return ct;
        });
    }
    async _fetchEditorInterface(id, editorInterfaces) {
        try {
            const response = await this.makeRequest({
                method: 'GET',
                url: `/content_types/${id}/editor_interface`
            });
            editorInterfaces.set(id, response);
        }
        catch (error) {
            if (error.name === 'NotFound') { // TODO: expose status codes and use that instead.
                // Initialize a default structure for newly created content types.
                editorInterfaces.set(id, {
                    sys: {
                        version: 0
                    },
                    controls: []
                });
            }
            else {
                throw error;
            }
        }
    }
}
exports.default = Fetcher;
//# sourceMappingURL=fetcher.js.map